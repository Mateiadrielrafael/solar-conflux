{"version":3,"file":"index.esm.js","sources":["../src/internals.ts","../src/types.ts","../src/helpers/isNone.ts","../src/helpers/isSome.ts","../src/helpers/match.ts","../src/helpers/bind.ts","../src/helpers/bindAsync.ts","../src/helpers/count.ts","../src/helpers/exists.ts","../src/helpers/filter.ts","../src/helpers/flat.ts","../src/helpers/fold.ts","../src/helpers/foldback.ts","../src/helpers/forall.ts","../src/helpers/fromArray.ts","../src/helpers/fromNullable.ts","../src/helpers/get.ts","../src/helpers/iter.ts","../src/helpers/map.ts","../src/helpers/mapAsync.ts","../src/helpers/toArray.ts","../src/helpers/toNullable.ts","../src/helpers/withDefault.ts"],"sourcesContent":["export const identity = <T>(v: T) => v\n\nexport const none = Symbol('none')\n","import { none, identity } from './internals'\nimport { Brand } from 'utility-types'\n\n// This is never actually used outside of typing so we can just declare it\ndeclare const some: unique symbol\n\ntype None = Brand<void, typeof none>\ntype Some<T> = Brand<T, typeof some>\n\nexport type Option<T> = Some<T> | None\n\nexport const None = {\n    __brand: none,\n    toString: () => 'None'\n} as None\nexport const Some = identity as <T>(value: T) => Option<T>\n","import { Option } from '../types'\nimport { none } from '../internals'\n\nexport const isNone = <T>(option: Option<T>) => option.__brand === none\n","import { Option } from '../types'\nimport { isNone } from './isNone'\n\nexport const isSome = <T>(option: Option<T>) => !isNone(option)\n","import { Option } from '../types'\nimport { Mapper } from '../internalTypes'\nimport { isSome } from './isSome'\n\nexport const match = <T, U>(\n    caseSome: Mapper<T, U>,\n    _default: U,\n    option: Option<T>\n) => {\n    if (isSome(option)) {\n        return caseSome(option as T)\n    }\n\n    return _default\n}\n","import { Binder } from '../internalTypes'\nimport { Option, None } from '../types'\nimport { match } from './match'\n\nexport const bind = <T, U>(\n    binder: Binder<T, U>,\n    option: Option<T>\n): Option<U> => {\n    return match(binder, None, option)\n}\n","import { Mapper } from '../internalTypes'\nimport { Option, None } from '../types'\nimport { match } from './match'\n\nexport const bindAsync = <T, U>(\n    binder: Mapper<T, Promise<Option<U>>>,\n    option: Option<T>\n): Promise<Option<U>> => {\n    return match(binder, Promise.resolve(None), option)\n}\n","import { Option } from '../types'\nimport { isSome } from './isSome'\n\nexport const count = <T>(option: Option<T>) => Number(isSome(option))\n","import { match } from './match'\nimport { Predicate } from '../internalTypes'\nimport { Option } from '../types'\n\nexport const exists = <T>(predicate: Predicate<T>, option: Option<T>) => {\n    return match(predicate, false, option)\n}\n","import { match } from './match'\nimport { Some, None, Option } from '../types'\nimport { Predicate } from '../internalTypes'\n\nexport const filter = <T>(predicate: Predicate<T>, option: Option<T>) => {\n    return match(v => (predicate(v) ? Some(v) : None), None, option)\n}\n","import { bind } from './bind'\nimport { identity } from '../internals'\nimport { Option } from '../types'\n\nexport const flat = <T>(option: Option<Option<T>>): Option<T> => {\n    return bind(identity, option)\n}\n","import { match } from './match'\nimport { Option } from '../types'\nimport { Folder } from '../internalTypes'\n\nexport const fold = <T, U>(\n    folder: Folder<T, U>,\n    initial: U,\n    option: Option<T>\n) => {\n    return match(v => folder(initial, v), initial, option)\n}\n","import { match } from './match'\nimport { Option } from '../types'\nimport { BackFolder } from '../internalTypes'\n\nexport const foldback = <T, U>(\n    folder: BackFolder<T, U>,\n    option: Option<T>,\n    initial: U\n) => {\n    return match(v => folder(v, initial), initial, option)\n}\n","import { match } from './match'\nimport { Predicate } from '../internalTypes'\nimport { Option } from '../types'\n\nexport const forall = <T>(predicate: Predicate<T>, option: Option<T>) => {\n    return match(predicate, true, option)\n}\n","import { None, Some, Option } from '../types'\n\nexport const fromArray = <T>(value: [T] | []): Option<T> => {\n    return value[0] === undefined ? None : Some(value[0])\n}\n","import { Nullable } from '../internalTypes'\nimport { Some, None, Option } from '../types'\n\nexport const fromNullable = <T>(value: Nullable<T>): Option<T> => {\n    return value === null ? None : Some(value)\n}\n","import { Option } from '../types'\nimport { isSome } from './isSome'\n\nexport const get = <T>(option: Option<T>): T => {\n    if (isSome(option)) {\n        return option as T\n    }\n\n    throw new Error(`Cannot get value of None`)\n}\n","import { Mapper } from '../internalTypes'\nimport { Option } from '../types'\nimport { isSome } from './isSome'\n\nexport const iter = <T>(mapper: Mapper<T, void>, option: Option<T>) => {\n    if (isSome(option)) {\n        mapper(option as T)\n    }\n}\n","import { match } from './match'\nimport { Mapper } from '../internalTypes'\nimport { Option, Some, None } from '../types'\n\nexport const map = <T, U>(\n    mapper: Mapper<T, U>,\n    option: Option<T>\n): Option<U> => {\n    return match(v => Some(mapper(v)), None, option)\n}\n","import { Option, None, Some } from '../types'\nimport { Mapper } from '../internalTypes'\nimport { match } from './match'\n\nexport const mapAsync = <T, U>(\n    mapper: Mapper<T, Promise<U>>,\n    option: Option<T>\n) => {\n    return match(\n        value => mapper(value).then(Some),\n        Promise.resolve(None),\n        option\n    )\n}\n","import { match } from './match'\nimport { Option } from '../types'\n\nexport const toArray = <T>(option: Option<T>) => {\n    return match(v => [v], [], option)\n}\n","import { match } from './match'\nimport { identity } from '../internals'\nimport { Option } from '../types'\n\nexport const toNullable = <T>(option: Option<T>) => {\n    return match(identity, null, option)\n}\n","import { match } from './match'\nimport { identity } from '../internals'\nimport { Option } from '../types'\n\nexport const withDefault = <T>(_default: T, option: Option<T>) => {\n    return match(identity, _default, option)\n}\n"],"names":["identity","v","none","Symbol","None","__brand","toString","Some","isNone","option","isSome","match","caseSome","_default","bind","binder","bindAsync","Promise","resolve","count","Number","exists","predicate","filter","flat","fold","folder","initial","foldback","forall","fromArray","value","undefined","fromNullable","get","Error","iter","mapper","map","mapAsync","then","toArray","toNullable","withDefault"],"mappings":"AAAO,IAAMA,EAAW,SAAIC,GAAS,OAAAA,GAExBC,EAAOC,OAAO,QCSdC,EAAO,CAChBC,QAASH,EACTI,SAAU,WAAM,MAAA,SAEPC,EAAOP,ECZPQ,EAAS,SAAIC,GAAsB,OAAAA,EAAOJ,UAAYH,GCAtDQ,EAAS,SAAID,GAAsB,OAACD,EAAOC,ICC3CE,EAAQ,SACjBC,EACAC,EACAJ,GAEA,OAAIC,EAAOD,GACAG,EAASH,GAGbI,GCTEC,EAAO,SAChBC,EACAN,GAEA,OAAOE,EAAMI,EAAQX,EAAMK,ICJlBO,EAAY,SACrBD,EACAN,GAEA,OAAOE,EAAMI,EAAQE,QAAQC,QAAQd,GAAOK,ICLnCU,EAAQ,SAAIV,GAAsB,OAAAW,OAAOV,EAAOD,KCChDY,EAAS,SAAIC,EAAyBb,GAC/C,OAAOE,EAAMW,GAAW,EAAOb,ICDtBc,EAAS,SAAID,EAAyBb,GAC/C,OAAOE,GAAM,SAAAV,GAAK,OAACqB,EAAUrB,GAAKM,EAAKN,GAAKG,IAAOA,EAAMK,ICDhDe,EAAO,SAAIf,GACpB,OAAOK,EAAKd,EAAUS,ICDbgB,EAAO,SAChBC,EACAC,EACAlB,GAEA,OAAOE,GAAM,SAAAV,GAAK,OAAAyB,EAAOC,EAAS1B,KAAI0B,EAASlB,ICLtCmB,EAAW,SACpBF,EACAjB,EACAkB,GAEA,OAAOhB,GAAM,SAAAV,GAAK,OAAAyB,EAAOzB,EAAG0B,KAAUA,EAASlB,ICLtCoB,EAAS,SAAIP,EAAyBb,GAC/C,OAAOE,EAAMW,GAAW,EAAMb,ICHrBqB,EAAY,SAAIC,GACzB,YAAoBC,IAAbD,EAAM,GAAmB3B,EAAOG,EAAKwB,EAAM,KCAzCE,EAAe,SAAIF,GAC5B,OAAiB,OAAVA,EAAiB3B,EAAOG,EAAKwB,ICD3BG,EAAM,SAAIzB,GACnB,GAAIC,EAAOD,GACP,OAAOA,EAGX,MAAM,IAAI0B,MAAM,6BCJPC,EAAO,SAAIC,EAAyB5B,GACzCC,EAAOD,IACP4B,EAAO5B,ICFF6B,EAAM,SACfD,EACA5B,GAEA,OAAOE,GAAM,SAAAV,GAAK,OAAAM,EAAK8B,EAAOpC,MAAKG,EAAMK,ICJhC8B,EAAW,SACpBF,EACA5B,GAEA,OAAOE,GACH,SAAAoB,GAAS,OAAAM,EAAON,GAAOS,KAAKjC,KAC5BU,QAAQC,QAAQd,GAChBK,ICRKgC,EAAU,SAAIhC,GACvB,OAAOE,GAAM,SAAAV,GAAK,MAAA,CAACA,KAAI,GAAIQ,ICAlBiC,EAAa,SAAIjC,GAC1B,OAAOE,EAAMX,EAAU,KAAMS,ICDpBkC,EAAc,SAAI9B,EAAaJ,GACxC,OAAOE,EAAMX,EAAUa,EAAUJ"}