{"version":3,"file":"index.cjs.js","sources":["../src/internals.ts","../src/types.ts","../src/helpers/isNone.ts","../src/helpers/isSome.ts","../src/helpers/match.ts","../src/helpers/bind.ts","../src/helpers/bindAsync.ts","../src/helpers/count.ts","../src/helpers/exists.ts","../src/helpers/filter.ts","../src/helpers/flat.ts","../src/helpers/fold.ts","../src/helpers/foldback.ts","../src/helpers/forall.ts","../src/helpers/fromArray.ts","../src/helpers/fromNullable.ts","../src/helpers/get.ts","../src/helpers/iter.ts","../src/helpers/map.ts","../src/helpers/mapAsync.ts","../src/helpers/toArray.ts","../src/helpers/toNullable.ts","../src/helpers/withDefault.ts"],"sourcesContent":["export const identity = <T>(v: T) => v\n\nexport const none = Symbol('none')\n","import { none, identity } from './internals'\nimport { Brand } from 'utility-types'\n\n// This is never actually used outside of typing so we can just declare it\ndeclare const some: unique symbol\n\ntype None = Brand<void, typeof none>\ntype Some<T> = Brand<T, typeof some>\n\nexport type Option<T> = Some<T> | None\n\nexport const None = {\n    __brand: none,\n    toString: () => 'None'\n} as None\nexport const Some = identity as <T>(value: T) => Option<T>\n","import { Option } from '../types'\nimport { none } from '../internals'\n\nexport const isNone = <T>(option: Option<T>) => option.__brand === none\n","import { Option } from '../types'\nimport { isNone } from './isNone'\n\nexport const isSome = <T>(option: Option<T>) => !isNone(option)\n","import { Option } from '../types'\nimport { Mapper } from '../internalTypes'\nimport { isSome } from './isSome'\n\nexport const match = <T, U>(\n    caseSome: Mapper<T, U>,\n    _default: U,\n    option: Option<T>\n) => {\n    if (isSome(option)) {\n        return caseSome(option as T)\n    }\n\n    return _default\n}\n","import { Binder } from '../internalTypes'\nimport { Option, None } from '../types'\nimport { match } from './match'\n\nexport const bind = <T, U>(\n    binder: Binder<T, U>,\n    option: Option<T>\n): Option<U> => {\n    return match(binder, None, option)\n}\n","import { Mapper } from '../internalTypes'\nimport { Option, None } from '../types'\nimport { match } from './match'\n\nexport const bindAsync = <T, U>(\n    binder: Mapper<T, Promise<Option<U>>>,\n    option: Option<T>\n): Promise<Option<U>> => {\n    return match(binder, Promise.resolve(None), option)\n}\n","import { Option } from '../types'\nimport { isSome } from './isSome'\n\nexport const count = <T>(option: Option<T>) => Number(isSome(option))\n","import { match } from './match'\nimport { Predicate } from '../internalTypes'\nimport { Option } from '../types'\n\nexport const exists = <T>(predicate: Predicate<T>, option: Option<T>) => {\n    return match(predicate, false, option)\n}\n","import { match } from './match'\nimport { Some, None, Option } from '../types'\nimport { Predicate } from '../internalTypes'\n\nexport const filter = <T>(predicate: Predicate<T>, option: Option<T>) => {\n    return match(v => (predicate(v) ? Some(v) : None), None, option)\n}\n","import { bind } from './bind'\nimport { identity } from '../internals'\nimport { Option } from '../types'\n\nexport const flat = <T>(option: Option<Option<T>>): Option<T> => {\n    return bind(identity, option)\n}\n","import { match } from './match'\nimport { Option } from '../types'\nimport { Folder } from '../internalTypes'\n\nexport const fold = <T, U>(\n    folder: Folder<T, U>,\n    initial: U,\n    option: Option<T>\n) => {\n    return match(v => folder(initial, v), initial, option)\n}\n","import { match } from './match'\nimport { Option } from '../types'\nimport { BackFolder } from '../internalTypes'\n\nexport const foldback = <T, U>(\n    folder: BackFolder<T, U>,\n    option: Option<T>,\n    initial: U\n) => {\n    return match(v => folder(v, initial), initial, option)\n}\n","import { match } from './match'\nimport { Predicate } from '../internalTypes'\nimport { Option } from '../types'\n\nexport const forall = <T>(predicate: Predicate<T>, option: Option<T>) => {\n    return match(predicate, true, option)\n}\n","import { None, Some, Option } from '../types'\n\nexport const fromArray = <T>(value: [T] | []): Option<T> => {\n    return value[0] === undefined ? None : Some(value[0])\n}\n","import { Nullable } from '../internalTypes'\nimport { Some, None, Option } from '../types'\n\nexport const fromNullable = <T>(value: Nullable<T>): Option<T> => {\n    return value === null ? None : Some(value)\n}\n","import { Option } from '../types'\nimport { isSome } from './isSome'\n\nexport const get = <T>(option: Option<T>): T => {\n    if (isSome(option)) {\n        return option as T\n    }\n\n    throw new Error(`Cannot get value of None`)\n}\n","import { Mapper } from '../internalTypes'\nimport { Option } from '../types'\nimport { isSome } from './isSome'\n\nexport const iter = <T>(mapper: Mapper<T, void>, option: Option<T>) => {\n    if (isSome(option)) {\n        mapper(option as T)\n    }\n}\n","import { match } from './match'\nimport { Mapper } from '../internalTypes'\nimport { Option, Some, None } from '../types'\n\nexport const map = <T, U>(\n    mapper: Mapper<T, U>,\n    option: Option<T>\n): Option<U> => {\n    return match(v => Some(mapper(v)), None, option)\n}\n","import { Option, None, Some } from '../types'\nimport { Mapper } from '../internalTypes'\nimport { match } from './match'\n\nexport const mapAsync = <T, U>(\n    mapper: Mapper<T, Promise<U>>,\n    option: Option<T>\n) => {\n    return match(\n        value => mapper(value).then(Some),\n        Promise.resolve(None),\n        option\n    )\n}\n","import { match } from './match'\nimport { Option } from '../types'\n\nexport const toArray = <T>(option: Option<T>) => {\n    return match(v => [v], [], option)\n}\n","import { match } from './match'\nimport { identity } from '../internals'\nimport { Option } from '../types'\n\nexport const toNullable = <T>(option: Option<T>) => {\n    return match(identity, null, option)\n}\n","import { match } from './match'\nimport { identity } from '../internals'\nimport { Option } from '../types'\n\nexport const withDefault = <T>(_default: T, option: Option<T>) => {\n    return match(identity, _default, option)\n}\n"],"names":["identity","v","none","Symbol","None","__brand","toString","Some","isNone","option","isSome","match","caseSome","_default","bind","binder","bindAsync","Promise","resolve","count","Number","exists","predicate","filter","flat","fold","folder","initial","foldback","forall","fromArray","value","undefined","fromNullable","get","Error","iter","mapper","map","mapAsync","then","toArray","toNullable","withDefault"],"mappings":"oEAAO,MAAMA,SAAeC,GAASA,EAExBC,KAAOC,OAAO,QCSdC,KAAO,CAChBC,QAASH,KACTI,SAAU,IAAM,QAEPC,KAAOP,SCZPQ,OAAaC,GAAsBA,EAAOJ,UAAYH,KCAtDQ,OAAaD,IAAuBD,OAAOC,GCC3CE,MAAQ,CACjBC,EACAC,EACAJ,IAEIC,OAAOD,GACAG,EAASH,GAGbI,ECTEC,KAAO,CAChBC,EACAN,IAEOE,MAAMI,EAAQX,KAAMK,GCJlBO,UAAY,CACrBD,EACAN,IAEOE,MAAMI,EAAQE,QAAQC,QAAQd,MAAOK,GCLnCU,MAAYV,GAAsBW,OAAOV,OAAOD,ICChDY,OAAS,CAAIC,EAAyBb,IACxCE,MAAMW,GAAW,EAAOb,GCDtBc,OAAS,CAAID,EAAyBb,IACxCE,MAAMV,GAAMqB,EAAUrB,GAAKM,KAAKN,GAAKG,KAAOA,KAAMK,GCDhDe,KAAWf,GACbK,KAAKd,SAAUS,GCDbgB,KAAO,CAChBC,EACAC,EACAlB,IAEOE,MAAMV,GAAKyB,EAAOC,EAAS1B,GAAI0B,EAASlB,GCLtCmB,SAAW,CACpBF,EACAjB,EACAkB,IAEOhB,MAAMV,GAAKyB,EAAOzB,EAAG0B,GAAUA,EAASlB,GCLtCoB,OAAS,CAAIP,EAAyBb,IACxCE,MAAMW,GAAW,EAAMb,GCHrBqB,UAAgBC,QACLC,IAAbD,EAAM,GAAmB3B,KAAOG,KAAKwB,EAAM,ICAzCE,aAAmBF,GACX,OAAVA,EAAiB3B,KAAOG,KAAKwB,GCD3BG,IAAUzB,IACnB,GAAIC,OAAOD,GACP,OAAOA,EAGX,MAAM,IAAI0B,MAAM,6BCJPC,KAAO,CAAIC,EAAyB5B,KACzCC,OAAOD,IACP4B,EAAO5B,ICFF6B,IAAM,CACfD,EACA5B,IAEOE,MAAMV,GAAKM,KAAK8B,EAAOpC,IAAKG,KAAMK,GCJhC8B,SAAW,CACpBF,EACA5B,IAEOE,MACHoB,GAASM,EAAON,GAAOS,KAAKjC,MAC5BU,QAAQC,QAAQd,MAChBK,GCRKgC,QAAchC,GAChBE,MAAMV,GAAK,CAACA,GAAI,GAAIQ,GCAlBiC,WAAiBjC,GACnBE,MAAMX,SAAU,KAAMS,GCDpBkC,YAAc,CAAI9B,EAAaJ,IACjCE,MAAMX,SAAUa,EAAUJ"}